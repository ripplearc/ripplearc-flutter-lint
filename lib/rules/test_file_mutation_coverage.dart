import 'dart:io';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/visitor.dart';
import 'package:analyzer/error/error.dart' hide LintCode;
import 'package:analyzer/error/listener.dart';
import 'package:custom_lint_builder/custom_lint_builder.dart';
import 'package:path/path.dart' as path;

/// A lint rule that ensures each test file has a corresponding mutation test configuration.
///
/// This rule flags test files that don't have a matching mutation test configuration file
/// generated by AI, ensuring comprehensive test coverage through mutation testing.
///
/// Example of code that triggers this rule:
/// ```dart
/// // auth_repository_test.dart - Missing mutation test configuration
/// test('should authenticate user', () {
///   // test implementation
/// });
/// ```
///
/// Example of code that doesn't trigger this rule:
/// ```dart
/// // auth_repository_test.dart - Has corresponding auth_repository_test.mutation.yaml
/// test('should authenticate user', () {
///   // test implementation
/// });
/// ```
class TestFileMutationCoverage extends DartLintRule {
  const TestFileMutationCoverage() : super(code: _code);

  static const _code = LintCode(
    name: 'test_file_mutation_coverage',
    problemMessage: 'Missing mutation test configuration for this test file.',
    correctionMessage:
        'Generate a mutation test configuration file using AI for comprehensive test coverage.',
    errorSeverity: ErrorSeverity.ERROR,
  );

  @override
  void run(
    CustomLintResolver resolver,
    ErrorReporter reporter,
    CustomLintContext context,
  ) {
    context.registry.addCompilationUnit((node) {
      if (!_isTestFile(resolver.path)) return;
      _checkForMutationCoverage(resolver.path, node, reporter);
    });
  }

  bool _isTestFile(String filePath) {
    return filePath.contains('_test.dart') ||
        filePath.contains('/test/') ||
        path.basename(filePath).endsWith('_test.dart');
  }

  void _checkForMutationCoverage(
    String filePath,
    CompilationUnit node,
    ErrorReporter reporter,
  ) {
    if (!_hasMutationConfig(filePath)) {
      // Report error at the first test block or at the beginning of the file
      final firstTest = _findFirstTestBlock(node);
      if (firstTest != null) {
        reporter.atNode(firstTest, TestFileMutationCoverage._code);
      } else {
        reporter.atNode(node, TestFileMutationCoverage._code);
      }
    }
  }

  bool _hasMutationConfig(String testFilePath) {
    final directory = path.dirname(testFilePath);
    final fileName = path.basenameWithoutExtension(testFilePath);

    // Check for common mutation test config file extensions
    final possibleConfigFiles = [
      '$fileName.mutation.yaml',
      '$fileName.mutation.yml',
      '$fileName.mutest.yaml',
      '$fileName.mutest.yml',
      'mutation.yaml',
      'mutation.yml',
      'mutest.yaml',
      'mutest.yml',
    ];

    for (final configFile in possibleConfigFiles) {
      final configPath = path.join(directory, configFile);
      if (File(configPath).existsSync()) {
        return true;
      }
    }

    // Also check parent directories for global mutation config
    final parentDir = path.dirname(directory);
    if (parentDir != directory) {
      for (final configFile in possibleConfigFiles) {
        final configPath = path.join(parentDir, configFile);
        if (File(configPath).existsSync()) {
          return true;
        }
      }
    }

    return false;
  }

  AstNode? _findFirstTestBlock(CompilationUnit node) {
    final visitor = _TestBlockVisitor();
    node.accept(visitor);
    return visitor.firstTestBlock;
  }
}

class _TestBlockVisitor extends RecursiveAstVisitor<void> {
  AstNode? firstTestBlock;

  @override
  void visitMethodInvocation(MethodInvocation node) {
    final name = node.methodName.name;
    if ((name == 'test' || name == 'group') && firstTestBlock == null) {
      firstTestBlock = node;
    }
    super.visitMethodInvocation(node);
  }
}
